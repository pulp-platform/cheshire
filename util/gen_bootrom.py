#!/usr/bin/env python3
#
# Copyright 2022 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
#
# Nicole Narr <narrn@student.ethz.ch>
# Christopher Reinwardt <creinwar@student.ethz.ch>
#
# Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
# Florian Zaruba <zarubaf@iis.ee.ethz.ch>
# Stefan Mach <smach@iis.ee.ethz.ch>
# Thomas Benz <tbenz@iis.ee.ethz.ch>
# Paul Scheffler <paulsc@iis.ee.ethz.ch>
# Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
# Gianna Paulin <pauling@iis.ee.ethz.ch>
# Tim Fischer <fischeti@iis.ee.ethz.ch>

import os
import argparse

# Parse arguments.
parser = argparse.ArgumentParser(description="Generate thestral_bootrom.sv")
parser.add_argument("BINARY",
                    help="Binary image for which to create a bootrom")
parser.add_argument(
    "--sv-module",
    "-m",
    metavar="BINARY",
    help=
    "Combinatorial SystemVerilog module with `reg_interface`. Name of the SystemVerilog module"
)
# Parse arguments.
parser.add_argument(
    "-p",
    "--pad",
    action="store",
    default=0,
    type=int,
    help=
    "Pad to next power of two (if the value is not a power of two it is rounded appropriately)"
)
parser.add_argument("--arm-rom",
                    action="store_true",
                    help="Generate am Arm ROM code file.")
args = parser.parse_args()

# Read the bootrom binary.
with open(args.BINARY, "rb") as file:
    binary = file.read()

# Calculate length of bootrom.
# Fill up the binary with zeroes to the next power of two.
length = 8
while length < max(len(binary), args.pad):
    length *= 2

binary += b"\0" * (length - len(binary))


# Generate the words to be emitted.
def chunks(seq, size):
    return (seq[pos:pos + size] for pos in range(0, len(seq), size))


def format_word_bin(word):
    hex = ["{:08b}".format(int(x)) for x in word]
    return "".join(reversed(hex))


def format_word_hex(word):
    hex = ["{:02x}".format(int(x)) for x in word]
    hex += ["00"] * (4 - len(word))
    return "".join(reversed(hex))


def format_arm_rom(binary):
    words = list(enumerate(chunks(binary, 4)))
    return "\n".join(("{}".format(format_word_bin(x)) for i, x in words))


def format_binary(binary):
    words = list(enumerate(chunks(binary, 4)))
    num_words = len(words)
    return num_words, ";\n            ".join(
        ("{:03}: data_o = 32'h{} /* 0x{:04x} */".format(
            i, format_word_hex(x), i * 4) for i, x in words))


if args.arm_rom:
    words = format_arm_rom(binary)
    print(words)

if args.sv_module:
    num_words, words = format_binary(binary)

    # Emit the code.
    print("""
// Copyright 2022 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Stefan Mach <smach@iis.ee.ethz.ch>
// Thomas Benz <tbenz@iis.ee.ethz.ch>
// Paul Scheffler <paulsc@iis.ee.ethz.ch>
// Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by {script}; edit the script instead.

module {module_name} #(
    parameter int unsigned AddrWidth = 32,
    parameter int unsigned DataWidth = 32
)(
    input  logic                 clk_i,
    input  logic                 rst_ni,
    input  logic                 req_i,
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);
    localparam unsigned NumWords = {num_words};
    logic [$clog2(NumWords)-1:0] word;

    assign word = addr_i / (DataWidth / 8);

    always_comb begin
        data_o = '0;
        unique case (word)
        {words};
            default: data_o = '0;
        endcase
    end

endmodule
    """.strip().format(
        script=os.path.basename(__file__),
        module_name=args.sv_module,
        num_words=num_words,
        words=words,
    ))
